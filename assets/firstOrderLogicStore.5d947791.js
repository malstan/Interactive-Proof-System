import{k as n,P as s}from"./index.04e7caea.js";const f=n("firstOrderLogicStore",{state:()=>({currentMethod:"GSK",currentNotation:"tree",inputFormula:"",proof:[],history:[],leaves:[],sameLeaves:{exists:!1,applied:!1},fitchProving:!1,conclusion:null,hypotesis:[]}),getters:{getMethod:e=>e.currentMethod,getNotation:e=>e.currentNotation,getInputFormula:e=>e.inputFormula,getProof:e=>e.proof,isProving:e=>e.currentNotation=="tree"?e.leaves.length>0:e.fitchProving,isProven:e=>{var t,i,h;return e.currentMethod=="GSK"?e.leaves.length==0&&e.proof.length>0:e.currentNotation=="tree"?((t=e.hypotesis)==null?void 0:t.every(o=>o.used==!0))&&e.leaves.length==0&&e.proof.length>0:((i=e.proof[e.proof.length-1])==null?void 0:i.formula)==e.inputFormula&&((h=e.proof[e.proof.length-1])==null?void 0:h.depth)==0},getLeaves:e=>e.leaves,getHypotesis:e=>e.hypotesis,getConclusion:e=>e.conclusion},actions:{setFromCookies(){s.has("fol-formula")&&this.setInputFormula(s.get("fol-formula")),s.has("fol-leaves")&&this.setLeaves(s.get("fol-leaves")),s.has("fol-proof")&&(this.proof=s.get("fol-proof")),s.has("fol-history")&&this.setHistory(s.get("fol-history")),s.has("fol-hypo")&&(this.hypotesis=s.get("fol-hypo")),s.has("fol-method")?this.currentMethod=s.get("fol-method"):s.set("fol-method",this.currentMethod),s.has("fol-notation")?this.currentNotation=s.get("fol-notation"):s.set("fol-notation",this.currentNotation),s.has("fol-fitch")&&(this.conclusion=s.get("fol-fitch"),this.fitchProving=!0)},setMethod(e){this.currentMethod=e,this.clearTree(),s.set("fol-method",this.currentMethod)},setNotation(e){this.currentNotation=e,this.clearTree(),s.set("fol-notation",this.currentNotation)},setInputFormula(e){this.inputFormula=e},setFitchProoving(){this.fitchProving=!0,this.conclusion=this.inputFormula.includes("\u22A2")?this.inputFormula.split("\u22A2")[1]:this.inputFormula},setProof(e){this.proof=[e]},setLeaves(e){this.leaves=e},setSameLeaves(e){this.sameLeaves.exists=e},resetSameLeaves(){this.sameLeaves.exists=!1,this.sameLeaves.applied=!1},setHistory(e){this.history=e},pushLeaf(e){this.leaves.push(e)},spliceLeaves(e){this.leaves.splice(this.leaves.indexOf(e),1)},popLeaf(){return this.leaves.pop()},clearTree(){this.proof=[],s.remove("fol-proof"),this.leaves=[],s.remove("fol-leaves"),this.history=[],s.remove("fol-history"),this.hypotesis=[],s.remove("fol-hypo"),this.fitchProving=!1,this.conclusion=null,s.remove("fol-fitch")},addFormulaToProof(e,t){if(e.length>1)e[1].length>1?e[1].forEach(i=>this.addFormulaToProof(i,t)):this.addFormulaToProof(e[1][0],t);else if(e[0]===t[0]){if(this.sameLeaves.exists&&!this.sameLeaves.applied){this.sameLeaves.applied=!0;return}e[1]=[],t[1].forEach(i=>{var h;if(this.currentMethod=="ND"&&this.hypotesis.some(o=>o.hypo==i)){let o=this.hypotesis.findIndex(r=>r.hypo==i);this.findLeaf(this.history[this.history.length-1].proof,e[0],String.fromCharCode("a".charCodeAt(0)+o),[])||((h=t[3])==null?void 0:h.includes(i))?e[1].push([`[${i}]${String.fromCharCode("a".charCodeAt(0)+o)}`]):e[1].push(i)}else e[1].push([i])}),e.push(t[2])}},addRowToProof(e){this.proof.push(e)},addToHistory(){this.currentNotation=="tree"?this.history.push({proof:JSON.parse(JSON.stringify(this.proof)),leaves:JSON.parse(JSON.stringify(this.leaves)),hypotesis:JSON.parse(JSON.stringify(this.hypotesis))}):this.history.push({proof:JSON.parse(JSON.stringify(this.proof))}),s.set("fol-history",this.history)},retrieveFromHistory(){const e=this.history.pop();this.proof=e.proof,this.leaves=e==null?void 0:e.leaves,this.hypotesis=e==null?void 0:e.hypotesis,s.set("fol-proof",this.proof),s.set("fol-leaves",this.leaves),s.set("fol-hypo",this.hypotesis),s.set("fol-history",this.history)},addHypotesis(e){e.forEach(t=>{this.hypotesis.includes(t)||this.hypotesis.push({hypo:t,used:!1})})},checkHypotesis(e,t){if(this.hypotesis.some(i=>i.hypo==e)){let i=this.hypotesis.findIndex(o=>o.hypo==e);const h=this.findLeaf(this.proof,t,String.fromCharCode("a".charCodeAt(0)+i),[]);return this.hypotesis=this.hypotesis.map(o=>o.hypo==e&&h?{hypo:o.hypo,used:!0}:o),h}return!1},checkHypotesisForTerm(e){return this.hypotesis.some(t=>t.hypo.includes(e))},findLeaf(e,t,i,h){if((e==null?void 0:e.length)>1)if(e[2]&&!e[2].endsWith(")")&&h.push(e[2].slice(-1)),e[1].length>1){for(const o of e[1])if(this.findLeaf(o,t,i,JSON.parse(JSON.stringify(h))))return!0}else return this.findLeaf(e[1][0],t,i,JSON.parse(JSON.stringify(h)));else return e&&e[0]==t?h.includes(i):!1;return!1}}});export{f as F};
