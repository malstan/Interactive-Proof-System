import{k as n,P as s}from"./index.7a9aee17.js";const p=n("propositionalLogicStore",{state:()=>({currentMethod:"GSK",currentNotation:"tree",inputFormula:"",proof:[],history:[],leaves:[],sameLeaves:{exists:!1,applied:!1},fitchProving:!1,conclusion:null,hypotesis:[]}),getters:{getMethod:e=>e.currentMethod,getNotation:e=>e.currentNotation,getInputFormula:e=>e.inputFormula,getProof:e=>e.proof,isProving:e=>e.currentNotation=="tree"?e.leaves.length>0:e.fitchProving,isProven:e=>{var i,t;return e.currentMethod=="GSK"?e.leaves.length==0&&e.proof.length>0:e.currentNotation=="tree"?((i=e.hypotesis)==null?void 0:i.every(o=>o.used==!0))&&e.leaves.length==0&&e.proof.length>0:((t=e.proof[e.proof.length-1])==null?void 0:t.formula)==e.inputFormula},getLeaves:e=>e.leaves,getHypotesis:e=>e.hypotesis,getConclusion:e=>e.conclusion},actions:{setFromCookies(){s.has("pl-formula")&&this.setInputFormula(s.get("pl-formula")),s.has("pl-leaves")&&this.setLeaves(s.get("pl-leaves")),s.has("pl-proof")&&(this.proof=s.get("pl-proof")),s.has("pl-history")&&this.setHistory(s.get("pl-history")),s.has("pl-hypo")&&(this.hypotesis=s.get("pl-hypo")),s.has("pl-method")?this.currentMethod=s.get("pl-method"):s.set("pl-method",this.currentMethod),s.has("pl-notation")?this.currentNotation=s.get("pl-notation"):s.set("pl-notation",this.currentNotation),s.has("pl-fitch")&&(this.conclusion=s.get("pl-fitch"),this.fitchProving=!0)},setMethod(e){this.currentMethod=e,this.clearTree(),s.set("pl-method",this.currentMethod)},setNotation(e){this.currentNotation=e,this.clearTree(),s.set("pl-notation",this.currentNotation)},setInputFormula(e){this.inputFormula=e},setFitchProoving(){this.fitchProving=!0,this.conclusion=this.inputFormula.includes("\u22A2")?this.inputFormula.split("\u22A2")[1]:this.inputFormula},setProof(e){this.proof=[e]},setLeaves(e){this.leaves=e},setSameLeaves(e){this.sameLeaves.exists=e},resetSameLeaves(){this.sameLeaves.exists=!1,this.sameLeaves.applied=!1},setHistory(e){this.history=e},pushLeaf(e){this.leaves.push(e)},spliceLeaves(e){this.leaves.splice(this.leaves.indexOf(e),1)},popLeaf(){return this.leaves.pop()},clearTree(){this.proof=[],s.remove("pl-proof"),this.leaves=[],s.remove("pl-leaves"),this.history=[],s.remove("pl-history"),this.hypotesis=[],s.remove("pl-hypo"),this.fitchProving=!1,this.conclusion=null,s.remove("pl-fitch")},addFormulaToProof(e,i){if(e.length>1)e[1].length>1?e[1].forEach(t=>this.addFormulaToProof(t,i)):this.addFormulaToProof(e[1][0],i);else if(e[0]===i[0]){if(this.sameLeaves.exists&&!this.sameLeaves.applied){this.sameLeaves.applied=!0;return}e[1]=[],i[1].forEach(t=>{var o;if(this.currentMethod=="ND"&&this.hypotesis.some(h=>h.hypo==t)){let h=this.hypotesis.findIndex(r=>r.hypo==t);this.findLeaf(this.history[this.history.length-1].proof,e[0],String.fromCharCode("a".charCodeAt(0)+h),[])||((o=i[3])==null?void 0:o.includes(t))?e[1].push([`[${t}]${String.fromCharCode("a".charCodeAt(0)+h)}`]):e[1].push(t)}else e[1].push([t])}),e.push(i[2])}},addRowToProof(e){this.proof.push(e)},addToHistory(){this.currentNotation=="tree"?this.history.push({proof:JSON.parse(JSON.stringify(this.proof)),leaves:JSON.parse(JSON.stringify(this.leaves)),hypotesis:JSON.parse(JSON.stringify(this.hypotesis))}):this.history.push({proof:JSON.parse(JSON.stringify(this.proof))}),s.set("pl-history",this.history)},retrieveFromHistory(){const e=this.history.pop();this.proof=e.proof,this.leaves=e==null?void 0:e.leaves,this.hypotesis=e==null?void 0:e.hypotesis,s.set("pl-proof",this.proof),s.set("pl-leaves",this.leaves),s.set("pl-hypo",this.hypotesis),s.set("pl-history",this.history)},addHypotesis(e){e.forEach(i=>{this.hypotesis.includes(i)||this.hypotesis.push({hypo:i,used:!1})})},checkHypotesis(e,i){if(this.hypotesis.some(t=>t.hypo==e)){let t=this.hypotesis.findIndex(h=>h.hypo==e);const o=this.findLeaf(this.proof,i,String.fromCharCode("a".charCodeAt(0)+t),[]);return this.hypotesis=this.hypotesis.map(h=>h.hypo==e&&o?{hypo:h.hypo,used:!0}:h),o}return!1},findLeaf(e,i,t,o){if((e==null?void 0:e.length)>1)if(e[2]&&!e[2].endsWith(")")&&o.push(e[2].slice(-1)),e[1].length>1){for(const h of e[1])if(this.findLeaf(h,i,t,JSON.parse(JSON.stringify(o))))return!0}else return this.findLeaf(e[1][0],i,t,JSON.parse(JSON.stringify(o)));else return e&&e[0]==i?o.includes(t):!1;return!1}}});export{p as P};
